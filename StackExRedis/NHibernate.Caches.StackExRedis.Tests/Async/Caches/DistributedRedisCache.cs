//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using NHibernate.Cache;

namespace NHibernate.Caches.StackExRedis.Tests.Caches
{
	public partial class DistributedRedisCache : ICache
	{

		/// <inheritdoc />
		public Task<object> GetAsync(object key, CancellationToken cancellationToken)
		{
			try
			{
				// Use a random strategy to get the value.
				// A real distributed cache should use a proper load balancing.
				var strategy = _regionStrategies[_random.Next(0, _regionStrategies.Length - 1)];
				return strategy.GetAsync(key, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		/// <inheritdoc />
		public async Task PutAsync(object key, object value, CancellationToken cancellationToken)
		{
			foreach (var strategy in _regionStrategies)
			{
				await (strategy.PutAsync(key, value, cancellationToken));
			}
		}

		/// <inheritdoc />
		public async Task RemoveAsync(object key, CancellationToken cancellationToken)
		{
			foreach (var strategy in _regionStrategies)
			{
				await (strategy.RemoveAsync(key, cancellationToken));
			}
		}

		/// <inheritdoc />
		public async Task ClearAsync(CancellationToken cancellationToken)
		{
			foreach (var strategy in _regionStrategies)
			{
				await (strategy.ClearAsync(cancellationToken));
			}
		}

		/// <inheritdoc />
		public async Task LockAsync(object key, CancellationToken cancellationToken)
		{
			// A simple locking that requires all instances to obtain the lock
			// A real distributed cache should use something like the Redlock algorithm.
			try
			{
				foreach (var strategy in _regionStrategies)
				{
					await (strategy.LockAsync(key, cancellationToken));
				}

			}
			catch (CacheException)
			{
				foreach (var strategy in _regionStrategies)
				{
					await (strategy.UnlockAsync(key, cancellationToken));
				}
				throw;
			}
		}

		/// <inheritdoc />
		public async Task UnlockAsync(object key, CancellationToken cancellationToken)
		{
			foreach (var strategy in _regionStrategies)
			{
				await (strategy.UnlockAsync(key, cancellationToken));
			}
		}

	}
}
